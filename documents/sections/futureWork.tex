\subsection{Collections}\label{subsec:collections}
When managing even more complex buildings, it might be necessary to have collections of instances. This could be simple arrays, lists or something like the generics of Java. It might prove difficult to convey the concept to non-programmers, so the actual syntax should be defined together with future users.

\subsection{Graphical Editor for policy definition}\label{subsec:graphicaleditor}
Our DSL editor is text based and we have decided to use concepts and words commonly used in the industry \textit{(FM)}. The concepts are structured and used in the DSL so they offer a literal description of the meaning of the combined keywords. However, one needs to have some programming knowledge in order to understand --- and be able to use --- the expression language. Therefore, our DSL could be improved by developing a graphical editor in order to abstract the expression language and consequently make it simpler for users to use.

\subsection{Integration with existing systems}\label{subsec:integration}
As stated in the \nameref{sec:introduction}(section\ref{sec:introduction} ), our focal point in this project is not on subsystem integration. We started out by modeling some of the external systems mentioned by our interviewees --- but as we found more and more of those subsystems we decided that they are outside the scope of this paper. As all of the interviewees use CTS systems, it is recommended to persue integration to this system type in future work. Generalization towards this subsystem is in high demand, since it represents a potential vendor lock in trap, especially with regards to service.

\subsection{Enhanced Code Completion}\label{subsec:codecompletion}
Code completion is of great importance to our language because it really helps the user by guiding her with all possible options. Right now, our DSL has working code completion but in the future we would like to restrict code completion to respect code scopes in greater detail. For example if a user while defining a policy uses \texttt{TemperatureSensor} and \texttt{RadiatorActuator}, she gets a list of all \texttt{SensorTypes} and \texttt{ActuatorTypes} present in our DSL. In a future revision the scope will be respected and only \texttt{TemperatureSensor} and \texttt{RadiatorActuator} will be presented as valid options in that particular policy.

\subsection{Defining Actuator and Sensor types}\label{subsec:def-sensor-actuator-types}
During the \nameref{sec:evaluation} (section\ref{sec:evaluation}) we came to realize that some of the sensors and actuators needed to satisfy the requirements were not implemented in the DSL. Some were introduced iterativly, but this still does not give us the flexibility to define policies using actuators and sensors that are not already available in our DSL. Future work in this area might include some modification of our meta-model in order to accommodate runtime definitions of actuators and sensors - like we do with \textit{room types}. This will enhance the DSL's usability and flexibility and help make the DSL more adaptable.

\subsection{Prioritization}\label{subsec:looptime}
Prioritization of policies should be introduced in future versions of our language. Higher priorities could be given to policies handling situations like fire alarms for example. At the moment we imagine the DSL running in a loop that calls all active (determined using the \textit{schedules}) policies in every iteration, making the timespan between policy executions linear with the amount of active policies, assuming they are of same size and complexity. This could instead be based on a prioritization of room, room-type or policies adding extra flexibility and fine grained control to the language. For instance, specify that some policies should only run once in an hour, and others appear that they are handled instantaneous. 

\subsection{Policy Scheduling}\label{subsec:during}
In its current state, our DSL allows us to determine when the policies should be executed by using the already defined schedules. One or more policies can be executed based on one or more schedules. In the case we have several governing policies that run on different schedules, our DSL does not allow us to assign a specific schedule to a single governing policy. An interesting improvement that could increase our DSL's flexibility would be the ability to specify several schedules for each of the governing policies.